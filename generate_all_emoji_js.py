
import re
import os
# No longer using json for the array literal output, but it's good practice to keep it if other JSON ops are present.
# import json

# --- Configuration ---
LOCAL_EMOJI_FILE = "emoji-zwj-sequences.txt"
OUTPUT_JAVASCRIPT_FILE = "emoji_versions_data.js"

TARGET_VERSIONS_STR = [
    '2.0', '3.0', '4.0', '5.0', '12.0', '12.1', '13.0', '13.1',
    '15.0', '15.1', '16.0', '17.0'
]

emoji_zwj_sequences_by_version = {v: [] for v in TARGET_VERSIONS_STR}

# --- Core Parsing Function ---
def parse_local_emoji_data(local_filepath):
    """
    Reads the emoji-zwj-sequences.txt file from a local path and parses its contents.
    Filters for specified Unicode Emoji versions and converts hex code points
    into displayable Unicode strings.
    Stores these strings in the globally defined 'emoji_zwj_sequences_by_version' dictionary.
    Returns True on successful parsing, False on failure (e.g., file not found).
    """
    print(f"Attempting to read data from local file: {os.path.abspath(local_filepath)}")
    
    try:
        with open(local_filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: The file '{local_filepath}' was not found.")
        print("Please ensure the 'emoji-zwj-sequences.txt' file is in the same directory as this script,")
        print(f"or update LOCAL_EMOJI_FILE in the script to its correct full path. Current path: {os.getcwd()}")
        return False
    except IOError as e:
        print(f"Error reading file '{local_filepath}': {e}")
        return False
    except Exception as e:
        print(f"An unexpected error occurred while opening/reading '{local_filepath}': {e}")
        return False

    print("Parsing emoji sequences...")

    for line_num, line in enumerate(content.splitlines()):
        line = line.strip()

        if not line or line.startswith('#'):
            continue

        try:
            parts = line.split(';', 1)
            if len(parts) < 2:
                continue

            code_points_str, description_str = parts
            version_match = re.search(r'# E(\d+\.\d+)', description_str)
            if not version_match:
                continue

            full_emoji_version = version_match.group(1)

            if full_emoji_version not in TARGET_VERSIONS_STR:
                continue
            
            if "RGI_Emoji_ZWJ_Sequence" not in description_str:
                continue

            hex_codes = code_points_str.strip().split(' ')
            displayable_emoji_string = "".join([chr(int(h, 16)) for h in hex_codes])
            
            emoji_zwj_sequences_by_version[full_emoji_version].append(displayable_emoji_string)

        except ValueError as e:
            print(f"Skipping malformed hex data in line {line_num+1}: '{line}' - Error: {e}")
        except Exception as e:
            print(f"An unexpected error occurred on line {line_num+1}: '{line}' - Error: {e}")
    
    global_total_sequences = sum(len(seq_list) for seq_list in emoji_zwj_sequences_by_version.values())
    print(f"Parsing complete. Found {global_total_sequences} sequences across target versions {TARGET_VERSIONS_STR}.")
    return True

# --- Main Execution Block ---
if __name__ == "__main__":
    if parse_local_emoji_data(LOCAL_EMOJI_FILE):
        print(f"\n--- Generating JavaScript file '{OUTPUT_JAVASCRIPT_FILE}' ---")
        try:
            with open(OUTPUT_JAVASCRIPT_FILE, 'w', encoding='utf-8') as outfile:
                outfile.write("// This file was automatically generated by a Python script.\n")
                outfile.write("// It contains arrays of Unicode Emoji ZWJ sequences by version.\n")
                outfile.write("// Each element in the array is a displayable Unicode emoji string.\n")
                outfile.write("// (Note: Versions like '3.0' might have empty arrays if no ZWJ sequences were introduced for them in the source file.)\n\n")

                sorted_versions = sorted(TARGET_VERSIONS_STR, key=lambda v: [int(p) for p in v.split('.')])

                for version in sorted_versions:
                    sequences = emoji_zwj_sequences_by_version.get(version, [])
                    var_name = f"emoji_zwj_v{version.replace('.', '_')}" 
                    
                    outfile.write(f"\n// Unicode Emoji Version {version} ({len(sequences)} sequences)\n")
                    outfile.write(f"const {var_name} = [\n")

                    items_per_line = 40
                    indent_level = "    " # 4 spaces for array elements

                    for i in range(0, len(sequences)):
                        # Start a new line and add indentation for the first item of a line
                        if i % items_per_line == 0:
                            outfile.write(indent_level)
                        
                        # Write the emoji string, properly quoted
                        # Using repr() on the string ensures it's quoted and escaped correctly for JS
                        outfile.write(repr(sequences[i])) 
                        
                        # Add a comma if it's not the very last item in the entire array
                        if i < len(sequences) - 1:
                            outfile.write(", ")
                        
                        # If this is the 40th item on the line (or the last item in the array), add a newline
                        if (i + 1) % items_per_line == 0 or i == len(sequences) - 1:
                            outfile.write("\n")
                            
                    outfile.write("];\n") # Close the array declaration
            
            print(f"\nSuccessfully wrote the JavaScript data to '{OUTPUT_JAVASCRIPT_FILE}'")
            print(f"File saved at: {os.path.abspath(OUTPUT_JAVASCRIPT_FILE)}")

        except IOError as e:
            print(f"Error writing the output JavaScript file '{OUTPUT_JAVASCRIPT_FILE}': {e}")
        except Exception as e:
            print(f"An unexpected error occurred while writing the output file: {e}")
    else:
        print("Failed to parse emoji data from local file. Output JavaScript file not generated.")
